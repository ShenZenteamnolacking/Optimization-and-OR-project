

import pandas as pd
from pyomo.environ import *

# =====================================================
# 1. LOAD DATA FROM EXCEL
# =====================================================

xlsx = "dataset.xlsx"

products = pd.read_excel(xlsx, sheet_name="Products")
periods = pd.read_excel(xlsx, sheet_name="Periods")
quality = pd.read_excel(xlsx, sheet_name="Quality")
demand = pd.read_excel(xlsx, sheet_name="Demand")
returns_q = pd.read_excel(xlsx, sheet_name="Returns_Quality")
capacities = pd.read_excel(xlsx, sheet_name="Capacities")
prices = pd.read_excel(xlsx, sheet_name="Prices_Costs")
proc_costs = pd.read_excel(xlsx, sheet_name="Process_Costs")
emissions = pd.read_excel(xlsx, sheet_name="Emissions")
policy = pd.read_excel(xlsx, sheet_name="Policy").iloc[0]

P = products["p"].tolist()
T = periods["t"].tolist()
Q = quality["q"].tolist()

# Helper function
def d(df, keys, val):
    return df.set_index(keys)[val].to_dict()

D_N = d(demand, ["p","t"], "D_N")
D_R = d(demand, ["p","t"], "D_R")
a = d(returns_q, ["p","q","t"], "a")

Cap_prod = d(capacities, ["t"], "Cap_prod")
Cap_ref  = d(capacities, ["t"], "Cap_ref")
Cap_rec  = d(capacities, ["t"], "Cap_rec")

pi_N = d(prices, ["p","t"], "pi_N")
pi_R = d(prices, ["p","t"], "pi_R")
c_prod = d(prices, ["p","t"], "c_prod")
c_hold_N = d(prices, ["p","t"], "c_hold_N")
c_hold_R = d(prices, ["p","t"], "c_hold_R")

c_ref = d(proc_costs, ["p","q","t"], "c_ref")
c_rec = d(proc_costs, ["p","q","t"], "c_rec")
c_disp = d(proc_costs, ["p","q","t"], "c_disp")

e_prod = emissions.groupby("p")["e_prod"].mean().to_dict()
e_ref = d(emissions, ["p","q"], "e_ref")
e_rec = d(emissions, ["p","q"], "e_rec")
e_disp = d(emissions, ["p","q"], "e_disp")

beta = policy["beta"]
gamma = policy["gamma"]
rho = policy["rho"]
CO2Budget = policy["CO2Budget"]

# =====================================================
# 2. MODEL
# =====================================================

m = ConcreteModel()

m.P = Set(initialize=P)
m.T = Set(initialize=T, ordered=True)
m.Q = Set(initialize=Q)

m.x = Var(m.P, m.T, domain=NonNegativeReals)
m.uN = Var(m.P, m.T, domain=NonNegativeReals)
m.uR = Var(m.P, m.T, domain=NonNegativeReals)
m.sN = Var(m.P, m.T, domain=NonNegativeReals)
m.sR = Var(m.P, m.T, domain=NonNegativeReals)

m.yref = Var(m.P, m.Q, m.T, domain=NonNegativeReals)
m.yrec = Var(m.P, m.Q, m.T, domain=NonNegativeReals)
m.ydisp = Var(m.P, m.Q, m.T, domain=NonNegativeReals)

T_sorted = sorted(T)
t0 = T_sorted[0]

def r_value(p,t):
    return sum(a.get((p,q,t),0) for q in Q)

# Demand
m.DemandN = Constraint(m.P, m.T, rule=lambda m,p,t: m.uN[p,t] <= D_N[p,t])
m.DemandR = Constraint(m.P, m.T, rule=lambda m,p,t: m.uR[p,t] <= D_R[p,t])

# Inventory
def invN(m,p,t):
    if t == t0:
        return m.sN[p,t] == m.x[p,t] - m.uN[p,t]
    return m.sN[p,t] == m.sN[p,t-1] + m.x[p,t] - m.uN[p,t]
m.InvN = Constraint(m.P, m.T, rule=invN)

def invR(m,p,t):
    if t == t0:
        return m.sR[p,t] == sum(m.yref[p,q,t] for q in Q) - m.uR[p,t]
    return m.sR[p,t] == m.sR[p,t-1] + sum(m.yref[p,q,t] for q in Q) - m.uR[p,t]
m.InvR = Constraint(m.P, m.T, rule=invR)

# Returns
m.ReturnFlow = Constraint(
    m.P, m.T,
    rule=lambda m,p,t:
    sum(m.yref[p,q,t] + m.yrec[p,q,t] + m.ydisp[p,q,t] for q in Q) == r_value(p,t)
)

# Quality availability
m.Quality = Constraint(
    m.P, m.Q, m.T,
    rule=lambda m,p,q,t:
    m.yref[p,q,t] + m.yrec[p,q,t] + m.ydisp[p,q,t] <= a.get((p,q,t),0)
)

# Capacities
m.CapProd = Constraint(m.T, rule=lambda m,t: sum(m.x[p,t] for p in P) <= Cap_prod[t])
m.CapRef  = Constraint(m.T, rule=lambda m,t: sum(m.yref[p,q,t] for p in P for q in Q) <= Cap_ref[t])
m.CapRec  = Constraint(m.T, rule=lambda m,t: sum(m.yrec[p,q,t] for p in P for q in Q) <= Cap_rec[t])

# Circular policies
m.MaxDisp = Constraint(m.T, rule=lambda m,t: sum(m.ydisp[p,q,t] for p in P for q in Q) <= beta * sum(r_value(p,t) for p in P))
m.MinRecov = Constraint(m.T, rule=lambda m,t: sum(m.yref[p,q,t] + m.yrec[p,q,t] for p in P for q in Q) >= gamma * sum(r_value(p,t) for p in P))
m.MinRecycle = Constraint(m.T, rule=lambda m,t: sum(m.yrec[p,q,t] for p in P for q in Q) >= rho * sum(r_value(p,t) for p in P))

# CO2
m.CO2 = Constraint(
    rule=lambda m:
    sum(e_prod[p] * m.x[p,t] for p in P for t in T)
    + sum(
        e_ref[p,q]*m.yref[p,q,t]
        + e_rec[p,q]*m.yrec[p,q,t]
        + e_disp[p,q]*m.ydisp[p,q,t]
        for p in P for q in Q for t in T
    ) <= CO2Budget
)

# Objective
m.Obj = Objective(
    sense=maximize,
    rule=lambda m:
    sum(pi_N[p,t]*m.uN[p,t] + pi_R[p,t]*m.uR[p,t] for p in P for t in T)
    - sum(c_prod[p,t]*m.x[p,t] for p in P for t in T)
    - sum(c_hold_N[p,t]*m.sN[p,t] + c_hold_R[p,t]*m.sR[p,t] for p in P for t in T)
    - sum(
        c_ref[p,q,t]*m.yref[p,q,t]
        + c_rec[p,q,t]*m.yrec[p,q,t]
        + c_disp[p,q,t]*m.ydisp[p,q,t]
        for p in P for q in Q for t in T
    )
)

# =====================================================
# 3. SOLVE
# =====================================================

solver = SolverFactory("highs")
solver.solve(m)

# =====================================================
# 4. BEAUTIFUL RESULTS
# =====================================================

print("\n" + "="*60)
print(" OPTIMIZATION RESULTS â€“ IKEA CIRCULAR SUPPLY CHAIN ")
print("="*60)

print(f"\nðŸ’° Total Profit: {value(m.Obj):,.2f}")

total_prod = sum(value(m.x[p,t]) for p in P for t in T)
total_ref = sum(value(m.yref[p,q,t]) for p in P for q in Q for t in T)
total_rec = sum(value(m.yrec[p,q,t]) for p in P for q in Q for t in T)
total_disp = sum(value(m.ydisp[p,q,t]) for p in P for q in Q for t in T)

print("\nðŸ“¦ Global volumes:")
print(f"  â€¢ New production      : {total_prod:,.1f}")
print(f"  â€¢ Refurbished units   : {total_ref:,.1f}")
print(f"  â€¢ Recycled units      : {total_rec:,.1f}")
print(f"  â€¢ Disposed units      : {total_disp:,.1f}")

co2_used = sum(
    e_prod[p]*value(m.x[p,t]) +
    sum(
        e_ref[p,q]*value(m.yref[p,q,t]) +
        e_rec[p,q]*value(m.yrec[p,q,t]) +
        e_disp[p,q]*value(m.ydisp[p,q,t])
        for q in Q
    )
    for p in P for t in T
)

print("\nðŸŒ± COâ‚‚:")
print(f"  â€¢ COâ‚‚ used   : {co2_used:,.1f}")
print(f"  â€¢ COâ‚‚ budget : {CO2Budget:,.1f}")
print(f"  â€¢ Slack      : {CO2Budget - co2_used:,.1f}")

print("\nâœ… Model solved successfully.")
print("="*60)
