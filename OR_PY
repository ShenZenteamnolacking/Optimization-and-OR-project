

import pandas as pd
from pyomo.environ import *

# =====================================================
# 1. LOAD DATA FROM EXCEL
# =====================================================

xlsx = "dataset.xlsx"

products = pd.read_excel(xlsx, sheet_name="Products")
periods = pd.read_excel(xlsx, sheet_name="Periods")
quality = pd.read_excel(xlsx, sheet_name="Quality")
demand = pd.read_excel(xlsx, sheet_name="Demand")
returns_q = pd.read_excel(xlsx, sheet_name="Returns_Quality")
capacities = pd.read_excel(xlsx, sheet_name="Capacities")
prices = pd.read_excel(xlsx, sheet_name="Prices_Costs")
proc_costs = pd.read_excel(xlsx, sheet_name="Process_Costs")
emissions = pd.read_excel(xlsx, sheet_name="Emissions")
policy = pd.read_excel(xlsx, sheet_name="Policy").iloc[0]

P = products["p"].tolist()
T = periods["t"].tolist()
Q = quality["q"].tolist()

# Helper function
def d(df, keys, val):
    return df.set_index(keys)[val].to_dict()

D_N = d(demand, ["p","t"], "D_N")
D_R = d(demand, ["p","t"], "D_R")
a = d(returns_q, ["p","q","t"], "a")

Cap_prod = d(capacities, ["t"], "Cap_prod")
Cap_ref  = d(capacities, ["t"], "Cap_ref")
Cap_rec  = d(capacities, ["t"], "Cap_rec")

pi_N = d(prices, ["p","t"], "pi_N")
pi_R = d(prices, ["p","t"], "pi_R")
c_prod = d(prices, ["p","t"], "c_prod")
c_hold_N = d(prices, ["p","t"], "c_hold_N")
c_hold_R = d(prices, ["p","t"], "c_hold_R")

c_ref = d(proc_costs, ["p","q","t"], "c_ref")
c_rec = d(proc_costs, ["p","q","t"], "c_rec")
c_disp = d(proc_costs, ["p","q","t"], "c_disp")

e_prod = emissions.groupby("p")["e_prod"].mean().to_dict()
e_ref = d(emissions, ["p","q"], "e_ref")
e_rec = d(emissions, ["p","q"], "e_rec")
e_disp = d(emissions, ["p","q"], "e_disp")

beta = policy["beta"]
gamma = policy["gamma"]
rho = policy["rho"]
CO2Budget = policy["CO2Budget"]

# =====================================================
# 2. MODEL
# =====================================================

m = ConcreteModel()

m.P = Set(initialize=P)
m.T = Set(initialize=T, ordered=True)
m.Q = Set(initialize=Q)

m.x = Var(m.P, m.T, domain=NonNegativeReals)
m.uN = Var(m.P, m.T, domain=NonNegativeReals)
m.uR = Var(m.P, m.T, domain=NonNegativeReals)
m.sN = Var(m.P, m.T, domain=NonNegativeReals)
m.sR = Var(m.P, m.T, domain=NonNegativeReals)

m.yref = Var(m.P, m.Q, m.T, domain=NonNegativeReals)
m.yrec = Var(m.P, m.Q, m.T, domain=NonNegativeReals)
m.ydisp = Var(m.P, m.Q, m.T, domain=NonNegativeReals)

T_sorted = sorted(T)
t0 = T_sorted[0]

def r_value(p,t):
    return sum(a.get((p,q,t),0) for q in Q)

# Demand
m.DemandN = Constraint(m.P, m.T, rule=lambda m,p,t: m.uN[p,t] <= D_N[p,t])
m.DemandR = Constraint(m.P, m.T, rule=lambda m,p,t: m.uR[p,t] <= D_R[p,t])

# Inventory
def invN(m,p,t):
    if t == t0:
        return m.sN[p,t] == m.x[p,t] - m.uN[p,t]
    return m.sN[p,t] == m.sN[p,t-1] + m.x[p,t] - m.uN[p,t]
m.InvN = Constraint(m.P, m.T, rule=invN)

def invR(m,p,t):
    if t == t0:
        return m.sR[p,t] == sum(m.yref[p,q,t] for q in Q) - m.uR[p,t]
    return m.sR[p,t] == m.sR[p,t-1] + sum(m.yref[p,q,t] for q in Q) - m.uR[p,t]
m.InvR = Constraint(m.P, m.T, rule=invR)

# Returns
m.ReturnFlow = Constraint(
    m.P, m.T,
    rule=lambda m,p,t:
    sum(m.yref[p,q,t] + m.yrec[p,q,t] + m.ydisp[p,q,t] for q in Q) == r_value(p,t)
)

# Quality availability
m.Quality = Constraint(
    m.P, m.Q, m.T,
    rule=lambda m,p,q,t:
    m.yref[p,q,t] + m.yrec[p,q,t] + m.ydisp[p,q,t] <= a.get((p,q,t),0)
)

# Capacities
m.CapProd = Constraint(m.T, rule=lambda m,t: sum(m.x[p,t] for p in P) <= Cap_prod[t])
m.CapRef  = Constraint(m.T, rule=lambda m,t: sum(m.yref[p,q,t] for p in P for q in Q) <= Cap_ref[t])
m.CapRec  = Constraint(m.T, rule=lambda m,t: sum(m.yrec[p,q,t] for p in P for q in Q) <= Cap_rec[t])

# Circular policies
m.MaxDisp = Constraint(m.T, rule=lambda m,t: sum(m.ydisp[p,q,t] for p in P for q in Q) <= beta * sum(r_value(p,t) for p in P))
m.MinRecov = Constraint(m.T, rule=lambda m,t: sum(m.yref[p,q,t] + m.yrec[p,q,t] for p in P for q in Q) >= gamma * sum(r_value(p,t) for p in P))
m.MinRecycle = Constraint(m.T, rule=lambda m,t: sum(m.yrec[p,q,t] for p in P for q in Q) >= rho * sum(r_value(p,t) for p in P))

# CO2
m.CO2 = Constraint(
    rule=lambda m:
    sum(e_prod[p] * m.x[p,t] for p in P for t in T)
    + sum(
        e_ref[p,q]*m.yref[p,q,t]
        + e_rec[p,q]*m.yrec[p,q,t]
        + e_disp[p,q]*m.ydisp[p,q,t]
        for p in P for q in Q for t in T
    ) <= CO2Budget
)

# Objective
m.Obj = Objective(
    sense=maximize,
    rule=lambda m:
    sum(pi_N[p,t]*m.uN[p,t] + pi_R[p,t]*m.uR[p,t] for p in P for t in T)
    - sum(c_prod[p,t]*m.x[p,t] for p in P for t in T)
    - sum(c_hold_N[p,t]*m.sN[p,t] + c_hold_R[p,t]*m.sR[p,t] for p in P for t in T)
    - sum(
        c_ref[p,q,t]*m.yref[p,q,t]
        + c_rec[p,q,t]*m.yrec[p,q,t]
        + c_disp[p,q,t]*m.ydisp[p,q,t]
        for p in P for q in Q for t in T
    )
)

# =====================================================
# 3. SOLVE
# =====================================================

solver = SolverFactory("highs")
solver.solve(m)

# # =====================================================
# 4. BEAUTIFUL RESULTS (tables + KPIs)
# =====================================================

def v(var):
    return float(value(var))

# --- Totals
profit = v(m.Obj)

total_prod = sum(v(m.x[p,t]) for p in P for t in T)
total_ref  = sum(v(m.yref[p,q,t]) for p in P for q in Q for t in T)
total_rec  = sum(v(m.yrec[p,q,t]) for p in P for q in Q for t in T)
total_disp = sum(v(m.ydisp[p,q,t]) for p in P for q in Q for t in T)

total_returns = sum(r_value(p,t) for p in P for t in T)

co2_used = (
    sum(e_prod[p]*v(m.x[p,t]) for p in P for t in T)
    + sum(
        e_ref[p,q]*v(m.yref[p,q,t]) + e_rec[p,q]*v(m.yrec[p,q,t]) + e_disp[p,q]*v(m.ydisp[p,q,t])
        for p in P for q in Q for t in T
    )
)

recovery_rate = (total_ref + total_rec) / total_returns if total_returns > 0 else 0.0
recycling_rate = total_rec / total_returns if total_returns > 0 else 0.0
disposal_rate = total_disp / total_returns if total_returns > 0 else 0.0

# --- Header
print("\n" + "="*72)
print(" IKEA CIRCULAR OPTIMIZATION ‚Äî RESULTS DASHBOARD")
print("="*72)

print(f"\nüí∞ PROFIT")
print(f"  Total profit: {profit:,.2f}")

print(f"\nüå± CO‚ÇÇ CONSTRAINT")
print(f"  CO‚ÇÇ used   : {co2_used:,.2f}")
print(f"  CO‚ÇÇ budget : {CO2Budget:,.2f}")
print(f"  Slack      : {(CO2Budget - co2_used):,.2f}  (binding if ~0)")

print(f"\n‚ôªÔ∏è  CIRCULARITY KPIs (over all periods)")
print(f"  Total returns processed : {total_returns:,.1f}")
print(f"  Refurbished units       : {total_ref:,.1f}")
print(f"  Recycled units          : {total_rec:,.1f}")
print(f"  Disposed units          : {total_disp:,.1f}")
print(f"  Recovery rate (ref+rec) : {100*recovery_rate:,.2f}%")
print(f"  Recycling rate          : {100*recycling_rate:,.2f}%")
print(f"  Disposal rate           : {100*disposal_rate:,.2f}%")

# =====================================================
# Table 1: monthly aggregates
# =====================================================
rows = []
for t in T:
    prod_t = sum(v(m.x[p,t]) for p in P)
    ref_t  = sum(v(m.yref[p,q,t]) for p in P for q in Q)
    rec_t  = sum(v(m.yrec[p,q,t]) for p in P for q in Q)
    disp_t = sum(v(m.ydisp[p,q,t]) for p in P for q in Q)
    salesN_t = sum(v(m.uN[p,t]) for p in P)
    salesR_t = sum(v(m.uR[p,t]) for p in P)
    invN_t = sum(v(m.sN[p,t]) for p in P)
    invR_t = sum(v(m.sR[p,t]) for p in P)
    ret_t  = sum(r_value(p,t) for p in P)

    rows.append({
        "t": t,
        "Production": prod_t,
        "Returns": ret_t,
        "Refurbished": ref_t,
        "Recycled": rec_t,
        "Disposed": disp_t,
        "Sales_New": salesN_t,
        "Sales_Ref": salesR_t,
        "Inv_New_end": invN_t,
        "Inv_Ref_end": invR_t,
    })

df_t = pd.DataFrame(rows)
print("\n" + "-"*72)
print("Monthly summary (aggregated over products)")
print("-"*72)
print(df_t.round(2).to_string(index=False))

# =====================================================
# Table 2: product totals
# =====================================================
rows = []
for p in P:
    prod_p = sum(v(m.x[p,t]) for t in T)
    salesN_p = sum(v(m.uN[p,t]) for t in T)
    salesR_p = sum(v(m.uR[p,t]) for t in T)
    ref_p  = sum(v(m.yref[p,q,t]) for q in Q for t in T)
    rec_p  = sum(v(m.yrec[p,q,t]) for q in Q for t in T)
    disp_p = sum(v(m.ydisp[p,q,t]) for q in Q for t in T)
    ret_p  = sum(r_value(p,t) for t in T)

    rows.append({
        "Product": p,
        "Produced": prod_p,
        "Sold_New": salesN_p,
        "Sold_Ref": salesR_p,
        "Returns": ret_p,
        "Refurbished": ref_p,
        "Recycled": rec_p,
        "Disposed": disp_p,
    })

df_p = pd.DataFrame(rows)
print("\n" + "-"*72)
print("Totals by product (over all periods)")
print("-"*72)
print(df_p.round(2).to_string(index=False))

print("\n‚úÖ Done.")
print("="*72)
